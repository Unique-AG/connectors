name: "Services CI"

on:
  pull_request:
    branches:
      - main
    paths:
      - "services/**"
      - "packages/**"
      - "pnpm-lock.yaml"
      - ".github/workflows/services-ci.yaml"
      - ".github/workflows/_template-ci.yaml"
  workflow_dispatch:
    inputs:
      services:
        description: 'Services to run CI for (comma-separated, e.g., "teams-mcp,outlook-mcp" or "all")'
        required: true
        default: "all"

concurrency:
  group: services-ci-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

permissions:
  contents: read

jobs:
  detect-changes:
    name: Detect changes
    runs-on: ubuntu-latest
    outputs:
      services: ${{ steps.build-matrix.outputs.services }}
      packages-changed: ${{ steps.filter.outputs.packages }}
    steps:
      - uses: actions/checkout@v4

      - uses: dorny/paths-filter@v3
        if: github.event_name != 'workflow_dispatch'
        id: filter
        with:
          list-files: json
          filters: |
            services:
              - 'services/**'
            packages:
              - 'packages/**'

      # Builds a JSON array of {service, orm} objects to fan out into parallel CI matrix jobs.
      # Handles three scenarios:
      #   1. workflow_dispatch: uses user input (comma-separated list or "all"), validates against existing services/
      #   2. PR with service changes: extracts unique service names from changed file paths
      #   3. PR with only package changes: runs all services since packages are shared dependencies
      # If none of the above match, outputs an empty array so the CI job is skipped.
      #
      # ORM is detected per service by checking for conventional config files:
      #   - drizzle.config.ts → drizzle
      #   - prisma/schema.prisma → prisma
      #   - neither → none
      - name: Build service matrix
        id: build-matrix
        env:
          EVENT_NAME: ${{ github.event_name }}
          INPUT_SERVICES: ${{ github.event.inputs.services }}
          SERVICES_CHANGED: ${{ steps.filter.outputs.services }}
          SERVICES_FILES: ${{ steps.filter.outputs.services_files }}
          PACKAGES_CHANGED: ${{ steps.filter.outputs.packages }}
        run: |
          if [ "$EVENT_NAME" = "workflow_dispatch" ]; then
            available=$(find services -mindepth 1 -maxdepth 1 -type d -exec basename {} \; | sort)

            if [ "$INPUT_SERVICES" = "all" ]; then
              service_names=$available
            else
              IFS=',' read -ra requested <<< "$INPUT_SERVICES"
              service_names=""
              for service in "${requested[@]}"; do
                service=$(echo "$service" | xargs)
                if echo "$available" | grep -qx "$service"; then
                  service_names+="$service"$'\n'
                else
                  echo "::error::Unknown service: $service"
                  echo "Available services: $available"
                  exit 1
                fi
              done
            fi
          elif [ "$SERVICES_CHANGED" = "true" ]; then
            service_names=$(echo "$SERVICES_FILES" | jq -r '.[]' | grep -E '^services/[^/]+/' | cut -d'/' -f2 | sort -u)
          elif [ "$PACKAGES_CHANGED" = "true" ]; then
            # Packages are shared dependencies — run CI for all services to catch breakage
            service_names=$(find services -mindepth 1 -maxdepth 1 -type d -exec basename {} \; | sort)
          else
            echo "services=[]" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          matrix="["
          first=true
          for name in $service_names; do
            [ -z "$name" ] && continue
            if [ -f "services/$name/drizzle.config.ts" ]; then
              orm="drizzle"
            elif [ -f "services/$name/prisma/schema.prisma" ]; then
              orm="prisma"
            else
              orm="none"
            fi
            $first || matrix+=","
            matrix+="{\"service\":\"$name\",\"orm\":\"$orm\"}"
            first=false
          done
          matrix+="]"

          echo "services=$matrix" >> "$GITHUB_OUTPUT"
          echo "Services to validate: $matrix"

  # Fans out into one job per affected service using the reusable CI template.
  # ORM type is detected automatically in the build-matrix step above.
  ci:
    name: ${{ matrix.service }}
    needs: detect-changes
    if: needs.detect-changes.outputs.services != '[]'
    strategy:
      fail-fast: false
      matrix:
        include: ${{ fromJson(needs.detect-changes.outputs.services) }}
    uses: ./.github/workflows/_template-ci.yaml
    with:
      service-name: ${{ matrix.service }}
      service-path: services/${{ matrix.service }}
      orm: ${{ matrix.orm }}
